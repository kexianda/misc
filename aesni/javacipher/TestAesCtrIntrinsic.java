/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

/**
 * @test
 * @bug
 * @summary add intrinsics/paralleled algorithm for AES-CTR
 * @library /testlibrary
 *
 * @modules java.base/sun.misc
 *          java.management
 * @run main/othervm/timeout=600 -Xbatch  TestAesCtrIntrinsic
 *
 * @author Xianda, Ke
 */

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Random;
//import jdk.test.lib.*;

public class TestAesCtrIntrinsic {

    public static void main(String[] args) throws Exception {
        int errNo = 0;

        errNo += warmUp();
        
        errNo += testAesCtrArbitraryLength();

        errNo += testAesCtr_4Blocks_NISTData();

        errNo += testAesCtrMultiBlocks();

        errNo += testAesCtrCounterCarry();

        errNo += testAesCtr192();
        errNo += testAesCtr256();

        if(errNo > 0) {
            System.exit(1);
        }
    }

    public static int testAesCtr_4Blocks_NISTData() {
        // NIST Special Publication 800-38A  Data
        // http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf  Appendix F
        char[] test_plain_text =  {
                0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
                0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
                0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
                0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10};

        //Key 128
        char[] test_key_128 = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};

        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};

        char[] test_cipher_128_ctr ={
                0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce,
                0x98,0x06,0xf6,0x6b,0x79,0x70,0xfd,0xff,0x86,0x17,0x18,0x7b,0xb9,0xff,0xfd,0xff,
                0x5a,0xe4,0xdf,0x3e,0xdb,0xd5,0xd3,0x5e,0x5b,0x4f,0x09,0x02,0x0d,0xb0,0x3e,0xab,
                0x1e,0x03,0x1d,0xda,0x2f,0xbe,0x03,0xd1,0x79,0x21,0x70,0xa0,0xf3,0x00,0x9c,0xee};

        //convert to byte[]
        byte[] input = convertToBytes(test_plain_text);
        byte[] expectedOutput = convertToBytes(test_cipher_128_ctr);
        byte[] key = convertToBytes(test_key_128);
        byte[] counter = convertToBytes(test_init_counter);

        int errNo = 0;
        System.out.println("Testing AES-CTR(NISTData) begins:");
        errNo += testAesCtrCrypt(input, expectedOutput, key, counter, true);
        errNo += testAesCtrCrypt(expectedOutput, input, key, counter, false);
        System.out.println("Testing AES-CTR(NISTData) ends.");
        return errNo;
    }

    public static int testAesCtrMultiBlocks(){
        char[] cipher_128_ctr_texts = {
                0x8D,0xEE,0xBC,0x17,0xFD,0x06,0x1B,0xD8,0x9B,0xB8,0x7D,0x19,0x87,0xF0,0xCE,0x94,
                0x47,0x59,0x0F,0x48,0x12,0x05,0x26,0x1B,0x61,0xDA,0x16,0xB5,0x9F,0x34,0x16,0xC8,
                0x0D,0x44,0xAA,0x12,0x13,0xE5,0x5A,0x21,0xD1,0xC4,0xB9,0x69,0x64,0xCE,0x19,0x32,
                0x9F,0xE4,0x40,0xE5,0x91,0x93,0xFB,0xA2,0xB1,0x6C,0x56,0xB3,0x7C,0x06,0xC0,0x92,
                0xDD,0x63,0x28,0x88,0x65,0xF8,0xE2,0x7A,0x85,0x1E,0x47,0xEF,0xE9,0x31,0xC4,0x60,
                0x3B,0xFD,0x21,0x3C,0x2A,0x89,0x68,0x9F,0x78,0xA6,0xBC,0xF6,0x12,0xF9,0x98,0x69,
                0x48,0xAD,0xD9,0x0F,0x3E,0xA6,0x52,0x83,0x04,0x0B,0xCF,0x5C,0x26,0x9E,0x15,0x2A,
                0x14,0xF0,0xA5,0xEC,0x2A,0xAD,0x3C,0x79,0x64,0x28,0xCB,0xDC,0x85,0xF3,0xE0,0xC9,
                0xCE,0xE6,0xD8,0x44,0x23,0x8A,0x2D,0xF1,0xF2,0xC7,0x5F,0x7F,0x41,0xDF,0x9B,0x55,
                0x15,0x32,0x1E,0x04,0xFE,0xCD,0x90,0x9E,0x6B,0xCD,0xB1,0x34,0x16,0x2F,0xAE,0x49,
                0xC8,0xC6,0x2A,0x8F,0x41,0x47,0xE8,0xB2,0x35,0x00,0xBB,0xF5,0x7B,0xE1,0xFC,0x61,
                0x38,0x54,0xC6,0x99,0xAB,0xCB,0x49,0xF6,0x99,0xC5,0x9A,0xC0,0xB3,0xE4,0x09,0x59,
                0x6E,0xB6,0xF3,0x91,0xA6,0x92,0x0F,0x95,0x05,0x83,0xE8,0xA0,0xC1,0x76,0xE1,0x8B
        };
        char[] test_key_128 = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};

        int dataSize = cipher_128_ctr_texts.length;
        byte[] input = new byte[dataSize];
        for(int i=0; i<dataSize; i++){
            input[i] = (byte) (byte)('a' + i%26);
        }

        byte[] expectedOutput = convertToBytes(cipher_128_ctr_texts);
        byte[] key = convertToBytes(test_key_128);
        byte[] counter = convertToBytes(test_init_counter);

        int errNo = 0;
        System.out.println("Testing AES-CTR(Multi blocks) begins:");
        errNo += testAesCtrCrypt(input, expectedOutput, key, counter, true);
        errNo += testAesCtrCrypt(expectedOutput, input, key, counter, false);
        System.out.println("Testing AES-CTR(Multi blocks) ends.");
        return errNo;
    }

    public static int testAesCtrCounterCarry() {
        char[] test_cipher_text_carry_counter = {
                0x5C,0x25,0x0A,0x13,0x21,0x02,0x1F,0x2A,0x16,0xD0,0x83,0xAC,0x78,0x5C,0x64,0x03,
                0x00,0x5C,0xE2,0x67,0x7F,0x78,0xB1,0xA0,0xD5,0x07,0xD3,0xF5,0x63,0x85,0x43,0xFF,
                0xA8,0x93,0x79,0xF6,0xBF,0x9F,0xDE,0x1C,0x86,0x9C,0x16,0x9A,0x8E,0x14,0xAE,0xEF,
                0xB0,0x74,0x71,0x3D,0xEC,0xDF,0xA5,0x83,0x41,0xBD,0xF2,0x1D,0x84,0x75,0xCA,0x66,
                0x34,0x58,0x54,0x7E,0x5E,0x03,0x68,0x44,0x02,0xA2,0xC4,0x6C,0xC2,0x00,0xD9,0xA4,
                0x14,0x98,0x71,0x68,0x55,0xB3,0x11,0x2B,0xC7,0xA7,0x4E,0xCE,0x09,0xA1,0x7F,0xD6,
                0x6E,0x05,0xF3,0xEC,0x2C,0xAD,0xE5,0x51,0x8A,0xBF,0x32,0x62,0xA4,0x00,0x08,0xFF,
                0x4F,0x2F,0x54,0x1F,0xF1,0x2C,0x61,0x6E,0x38,0x5B,0x58,0xEF,0x44,0xFD,0x74,0x21,
                0x4E,0x98,0x2E,0x4C,0xA6,0xD4,0xBA,0x5C,0xCD,0x2A,0xD1,0x53,0x41,0xB0,0x48,0x06,
                0x38,0xFB,0x84,0x76,0x6E,0x02,0xAD,0x68,0x05,0x07,0xE6,0xE3,0xDD,0xD5,0x38,0x7E,
                0x8F,0xC3,0x84,0x6F,0x3F,0x85,0xEF,0x2D,0x60,0x6C,0xF6,0x08,0x8C,0x57,0x1F,0xBE,
                0xF1,0x22,0x68,0x1A,0x34,0x7B,0x2B,0x56,0xE2,0x63,0xA8,0xFC,0x2F,0xF3,0x3B,0x2A,
                0x42,0x0F,0x0F,0xC0,0x61,0xE6,0x6E,0xB2,0x43,0x21,0xB0,0x48,0x36,0xA5,0x7F,0x18,
                0x6E,0x1D,0x11,0xB1,0xA5,0x1A,0x21,0xA9,0x03,0x51,0x99,0x8E,0x2E,0xA8,0x0E,0xF6,
                0x53,0xE2,0x14,0xB9,0x30,0x75,0x86,0xE1,0x15,0x64,0x6E,0x75,0x41,0x7E,0x43,0xE8,
                0x31,0x16,0x9E,0x2C,0x17,0xC8,0xC6,0xE9,0x9B,0xA2,0x21,0x42,0xB2,0x0C,0x37,0x27};
        char[] test_carry_counter = {0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe};
        char[] test_key_128 = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};

        int dataSize = test_cipher_text_carry_counter.length;
        byte[] input = new byte[dataSize];
        for(int i=0; i<dataSize; i++){
            input[i] = (byte) (byte)('a' + i%26);
        }

        byte[] expectedOutput = convertToBytes(test_cipher_text_carry_counter);
        byte[] key = convertToBytes(test_key_128);
        byte[] counter = convertToBytes(test_carry_counter);

        int errNo = 0;
        System.out.println("Testing AES-CTR(counter carry) begins:");
        errNo += testAesCtrCrypt(input, expectedOutput, key, counter, true);
        errNo += testAesCtrCrypt(expectedOutput, input, key, counter, false);
        System.out.println("Testing AES-CTR(counter carry) ends.");
        return errNo;
    }

    public static int testAesCtrArbitraryLength() {
        //63
        char[] test_plain_text =  {
                0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
                0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
                0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
                0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37}; //,0x10

        //Key 128
        char[] test_key_128 = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};

        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};

        char[] test_cipher_128_ctr ={
                0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce,
                0x98,0x06,0xf6,0x6b,0x79,0x70,0xfd,0xff,0x86,0x17,0x18,0x7b,0xb9,0xff,0xfd,0xff,
                0x5a,0xe4,0xdf,0x3e,0xdb,0xd5,0xd3,0x5e,0x5b,0x4f,0x09,0x02,0x0d,0xb0,0x3e,0xab,
                0x1e,0x03,0x1d,0xda,0x2f,0xbe,0x03,0xd1,0x79,0x21,0x70,0xa0,0xf3,0x00,0x9c}; //,0xee

        //convert to byte[]
        byte[] input = convertToBytes(test_plain_text);
        byte[] expectedOutput = convertToBytes(test_cipher_128_ctr);
        byte[] keyBytes = convertToBytes(test_key_128);
        byte[] counter = convertToBytes(test_init_counter);

        int errNo = 0;
        System.out.println("Testing AES-CTR(Arbitrary Length) begins:");

        try{
            SecretKeySpec key = new SecretKeySpec(keyBytes, ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(counter);
            Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");

            byte[] output = new byte[input.length];

            cipher.init((Cipher.ENCRYPT_MODE), key, ivSpec);
            Random rand =  new Random();
            int offset= rand.nextInt(input.length+1); //0 ~ input.length
            cipher.update(input, 0, offset, output, 0);
            cipher.update(input, offset, input.length-offset, output, offset);

            if(compareArrays(output, expectedOutput) == 0) {
                System.out.println("Testing AES-CTR(Arbitrary Length) succeeded.");
            }
            else {
                errNo++;
            }

        } catch(Exception e){
            e.printStackTrace();
            errNo++;
        }

        return errNo;
    }

    public static int testAesCtr192() {
        //--NIST Special Publication 800-38A  Data----------------------------------------------------
        //http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
        int errNo = 0;
        char[] test_plain_text =  {
                0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
                0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
                0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
                0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10};

        char[] test_key_192 = {0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
                0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b};

        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};

        char[]  test_cipher_192_ctr ={ 0x1a,0xbc,0x93,0x24,0x17,0x52,0x1c,0xa2,0x4f,0x2b,0x04,0x59,0xfe,0x7e,0x6e,0x0b,
                0x09,0x03,0x39,0xec,0x0a,0xa6,0xfa,0xef,0xd5,0xcc,0xc2,0xc6,0xf4,0xce,0x8e,0x94,
                0x1e,0x36,0xb2,0x6b,0xd1,0xeb,0xc6,0x70,0xd1,0xbd,0x1d,0x66,0x56,0x20,0xab,0xf7,
                0x4f,0x78,0xa7,0xf6,0xd2,0x98,0x09,0x58,0x5a,0x97,0xda,0xec,0x58,0xc6,0xb0,0x50};

        errNo += checkCipherDoFinal(test_plain_text, test_cipher_192_ctr,test_key_192, test_init_counter, "CTR", true);
        errNo += checkCipherDoFinal(test_cipher_192_ctr, test_plain_text,test_key_192, test_init_counter, "CTR", false);
        return errNo;
    }

    public static int testAesCtr256() {
        //--NIST Special Publication 800-38A  Data----------------------------------------------------
        //http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
        int errNo = 0;
        char[] test_plain_text =  {
                0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
                0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
                0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
                0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10};

        char[] test_key_256=  {0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
                0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};  //32

        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};

        char[]  test_cipher_256_ctr ={ 0x60,0x1e,0xc3,0x13,0x77,0x57,0x89,0xa5,0xb7,0xa7,0xf5,0x04,0xbb,0xf3,0xd2,0x28,
                0xf4,0x43,0xe3,0xca,0x4d,0x62,0xb5,0x9a,0xca,0x84,0xe9,0x90,0xca,0xca,0xf5,0xc5,
                0x2b,0x09,0x30,0xda,0xa2,0x3d,0xe9,0x4c,0xe8,0x70,0x17,0xba,0x2d,0x84,0x98,0x8d,
                0xdf,0xc9,0xc5,0x8d,0xb6,0x7a,0xad,0xa6,0x13,0xc2,0xdd,0x08,0x45,0x79,0x41,0xa6};

        errNo += checkCipherDoFinal(test_plain_text, test_cipher_256_ctr, test_key_256, test_init_counter, "CTR", true);
        errNo += checkCipherDoFinal(test_cipher_256_ctr, test_plain_text, test_key_256, test_init_counter, "CTR", false);
        return errNo;
    }

    private static int checkCipherDoFinal(char[] input, char[] expectedOutput, char[] keyStr, char[] iv, String mode, boolean isEncrypt){
        int errNo = 0;
        try{
            byte[] keyBytes = convertToBytes(keyStr);
            byte[] ivBytes = convertToBytes(iv);
            byte[] inputBytes = convertToBytes(input);
            byte[] expectedOutputBytes = convertToBytes(expectedOutput);

            SecretKeySpec key = new SecretKeySpec(keyBytes, ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            Cipher cipher = Cipher.getInstance("AES/" + mode + "/NoPadding");

            cipher.init(isEncrypt? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, key, ivSpec);
            byte[] outputBytes = cipher.doFinal(inputBytes);

            if(compareArrays(outputBytes, expectedOutputBytes) == 0) {
                System.out.println("AES-" + mode + "(Keylen = " + keyStr.length * 8 +") succeeded.");
            }
            else {
                errNo++;
            }

        } catch(Exception e){
            System.out.println(e.getMessage());
        }
        return errNo;
    }

    static private int warmUp() {
        int errNo = 0;
        String mode = "CTR";
        char[] test_plain_text =  {
                0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
                0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
                0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
                0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10};
        //Key 128
        char[] test_key_128 = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
        char[] test_init_counter = { 0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};
        char[] test_cipher_128_ctr ={
                0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce,
                0x98,0x06,0xf6,0x6b,0x79,0x70,0xfd,0xff,0x86,0x17,0x18,0x7b,0xb9,0xff,0xfd,0xff,
                0x5a,0xe4,0xdf,0x3e,0xdb,0xd5,0xd3,0x5e,0x5b,0x4f,0x09,0x02,0x0d,0xb0,0x3e,0xab,
                0x1e,0x03,0x1d,0xda,0x2f,0xbe,0x03,0xd1,0x79,0x21,0x70,0xa0,0xf3,0x00,0x9c,0xee};

        byte[] input    = convertToBytes(test_plain_text);
        byte[] output   = convertToBytes(test_cipher_128_ctr);
        byte[] keyBytes = convertToBytes(test_key_128);
        byte[] ivBytes  = convertToBytes(test_init_counter);

        try{
            SecretKeySpec key = new SecretKeySpec(keyBytes, ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            Cipher cipher = Cipher.getInstance("AES/" + mode + "/NoPadding");

            //-XX:CompileThreshold
            // loopCnt > CompileThreshold
            int warmUpItr = 200000;

            //encryption
            cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
            for(int i=0; i < warmUpItr; i++) {
                cipher.doFinal(input);
            }
            System.out.println("AES-CTR encryption is warmed up.");

            //decryption
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);
            for(int i=0; i < warmUpItr; i++) {
                cipher.doFinal(output);
            }
            System.out.println("AES-CTR decryption is warmed up.");
        } catch(Exception e){
            System.out.println(e.getMessage());
            errNo++;
        }

        return errNo;
    }

    /*
    * length of Input must be multiple of BLOCK_SIZE 16
    * the length of input stream varies from 1 blocks to N blocks
    * */
    static private int testAesCtrCrypt(byte[] input, byte[] expectedOutput, byte[] keyBytes,  byte[] counter, boolean isEncrypt) {
        int errNo = 0;
        try{
            SecretKeySpec key = new SecretKeySpec(keyBytes, ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(counter);
            Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");

            int totalBlocks = input.length / BLOCK_SIZE;

            // the length of input stream varies,
            // from 1 blocks to N blocks
            for(int idx = 1; idx<= totalBlocks; idx++) {
                int chunkSize = BLOCK_SIZE * idx;

                byte[] tmpInput = new byte[chunkSize];
                byte[] tmpOutput = new byte[chunkSize];
                for (int i = 0; i < chunkSize; i++) {
                    tmpInput[i] = input[i];
                    tmpOutput[i] = expectedOutput[i];
                }

                cipher.init((isEncrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE), key, ivSpec);
                byte[] encOutput = cipher.doFinal(tmpInput);

                if(compareArrays(encOutput, tmpOutput) == 0) {
                    System.out.println(
                            "AES/CTR "
                                    + (isEncrypt ? " encryption" : " decryption")
                                    + "(" + idx + " blocks, "
                                    + " key len:" + key.getEncoded().length * 8 + "bits)"
                                    + " succeeded.");
                }
                else {
                    errNo++;
                }
            }
        } catch(Exception e){
            e.printStackTrace();
            errNo++;
        }

        return errNo;
    }

    static private void showArray(byte b[], String name) {
        System.out.format("%s [%d]: ", name, b.length);
        for (int i=0; i<b.length; i++) {
            System.out.format("%02x ", b[i] & 0xff);
        }
        System.out.println();
    }

    static private int compareArrays(byte b[], byte exp[]) {
        if (b.length != exp.length) {
            System.out.format("different lengths for actual and expected output arrays\n");
            showArray(b, "test: ");
            showArray(exp, "exp : ");
            return 1;
        }
        for (int i=0; i< exp.length; i++) {
            if (b[i] != exp[i]) {
                System.out.format("output error at index %d: got %02x, expected %02x\n", i, b[i] & 0xff, exp[i] & 0xff);
                showArray(b, "test: ");
                showArray(exp, "exp : ");
                return 1;
            }
        }
        return 0; // the same
    }

    static private byte[] convertToBytes(char[] in) {
        byte[] out = new byte[in.length];
        for(int i=0; i<in.length; i++){
            out[i] = (byte)in[i];
        }
        return out;
    }

    private static final int BLOCK_SIZE = 16;
    private static final String ALGORITHM = "AES";
    //private static final String PROVIDER = "SunJCE";
}

