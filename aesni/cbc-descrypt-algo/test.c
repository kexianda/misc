#include <stdlib.h>
#include <stdio.h>

//#ifdef __linux__
#include <time.h>
//#endif

#define BLOCK_SIZE 16

//todo:
//192, 256;
// when testing, realloc memory!!!

typedef unsigned char UCHAR;

//RDI, RSI, RDX, RCX, R8, R9, XMM0-7
extern int aes_cbc_decrypt(const UCHAR *plainText,  UCHAR *cipherText,  const UCHAR *key, UCHAR *iv,  size_t length, size_t keybit_length);
extern int aes_cbc_decrypt_old(const UCHAR *plainText,  UCHAR *cipherText,  const UCHAR *key, UCHAR *iv,  size_t length, size_t keybit_length);
extern int aes_cbc_decrypt_noparallel(const UCHAR *plainText,  UCHAR *cipherText,  const UCHAR *key, UCHAR *iv,  size_t length);

int cmp_array();
int verify();
int test_performance();
double timediff(long start_tv_sec, long start_tv_nsec, long end_tv_sec, long end_ntv_sec);

int main() {
	int ret = 0;

	if(verify() != 0) {
		return 1;
	}
	
	test_performance();
	return ret;
}


int test_performance() {

	//int chunkNumber, int chunkSize, int keybit_length, int isParallel
	test_performance_print(256, 1024*1024, 128, 1, 1);
	test_performance_print(256, 1024*1024, 192, 1, 1);
	test_performance_print(256, 1024*1024, 256, 1, 1);
	test_performance_print(256, 1024*1024, 128, 0, 1);
	test_performance_print(256, 1024*1024, 192, 0, 1);
	test_performance_print(256, 1024*1024, 256, 0, 1);

	//--------------------------------------------------------
	test_performance_print(256, 1024*64, 128, 1, 0);
	test_performance_print(256, 1024*64, 192, 1, 0);
	test_performance_print(256, 1024*64, 256, 1, 0);

	test_performance_print(256, 1024*64, 128, 0, 0);
	test_performance_print(256, 1024*64, 192, 0, 0);
	test_performance_print(256, 1024*64, 256, 0, 0);

	test_performance_print(256, 1024*64, 128, 1, 0);
	test_performance_print(256, 1024*64, 192, 1, 0);
	test_performance_print(256, 1024*64, 256, 1, 0);

	test_performance_print(256, 1024*64, 128, 0, 0);
	test_performance_print(256, 1024*64, 192, 0, 0);
	test_performance_print(256, 1024*64, 256, 0, 0);

	//-------------------------------------------------------
	test_performance_print(256, 1024*1024, 128, 1, 0);
	test_performance_print(256, 1024*1024, 192, 1, 0);
	test_performance_print(256, 1024*1024, 256, 1, 0);

	test_performance_print(256, 1024*1024, 128, 0, 0);
	test_performance_print(256, 1024*1024, 192, 0, 0);
	test_performance_print(256, 1024*1024, 256, 0, 0);

	test_performance_print(256, 1024*1024, 128, 1, 0);
	test_performance_print(256, 1024*1024, 192, 1, 0);
	test_performance_print(256, 1024*1024, 256, 1, 0);

	test_performance_print(256, 1024*1024, 128, 0, 0);
	test_performance_print(256, 1024*1024, 192, 0, 0);
	test_performance_print(256, 1024*1024, 256, 0, 0);

	//------------------------------------------------------
	test_performance_print(16, 1024*1024*64, 128, 1, 0);
	test_performance_print(16, 1024*1024*64, 192, 1, 0);
	test_performance_print(16, 1024*1024*64, 256, 1, 0);

	test_performance_print(16, 1024*1024*64, 128, 0, 0);
	test_performance_print(16, 1024*1024*64, 192, 0, 0);
	test_performance_print(16, 1024*1024*64, 256, 0, 0);

	test_performance_print(16, 1024*1024*64, 128, 1, 0);
	test_performance_print(16, 1024*1024*64, 192, 1, 0);
	test_performance_print(16, 1024*1024*64, 256, 1, 0);

	test_performance_print(16, 1024*1024*64, 128, 0, 0);
	test_performance_print(16, 1024*1024*64, 192, 0, 0);
	test_performance_print(16, 1024*1024*64, 256, 0, 0);

	return 0;
}


double _performance_interval (int chunkNum, int chunkSize, int keybit_length, int isParallel) {
	int i = 0, j = 0;

	//key {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
	UCHAR expandkey_128[BLOCK_SIZE * 11]= {
		0x16,0x15,0x7e,0x2b,0xa6,0xd2,0xae,0x28, 0x88,0x15,0xf7,0xab,0x3c,0x4f,0xcf,0x09,
		0xa8,0xf9,0x14,0xd0,0x89,0x25,0xee,0xc9, 0xc8,0x0c,0x3f,0xe1,0xa6,0x0c,0x63,0xb6,
		0x63,0x5a,0x7b,0x0c,0xfe,0xea,0x19,0x13, 0x90,0x88,0x39,0xb0,0xb4,0xfb,0x4c,0x66,
		0x5a,0x92,0x7d,0xdf,0x9d,0xb0,0x62,0x1f, 0x6e,0x62,0x20,0xa3,0x24,0x73,0x75,0xd6,
		0x47,0x76,0xc0,0x12,0xc7,0x22,0x1f,0xc0, 0xf3,0xd2,0x42,0xbc,0x4a,0x11,0x55,0x75,
		0x76,0xd8,0xfc,0x6e,0x80,0x54,0xdf,0xd2, 0x34,0xf0,0x5d,0x7c,0xb9,0xc3,0x17,0xc9,
		0xfc,0x0a,0xa3,0x6e,0xf6,0x8c,0x23,0xbc, 0xb4,0xa4,0x82,0xae,0x8d,0x33,0x4a,0xb5,
		0x13,0x44,0x88,0x90,0x0a,0x86,0x80,0xd2, 0x42,0x28,0xa1,0x12,0x39,0x97,0xc8,0x1b,
		0xf7,0x13,0x1f,0x7c,0x19,0xc2,0x08,0x42, 0x48,0xae,0x21,0xc0,0x7b,0xbf,0x69,0x09,
		0xeb,0x05,0x75,0xcc,0xee,0xd1,0x17,0x3e, 0x51,0x6c,0x29,0x82,0x33,0x11,0x48,0xc9,
		0xa7,0x08,0x37,0x2b,0x05,0xd4,0x62,0xf2, 0xbf,0xbd,0x3e,0xbc,0x62,0x7d,0x61,0x4b
	};
	//test_key_192 = {0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,0x62, 
    //			0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b};
	UCHAR expandkey_192[BLOCK_SIZE * 13]= {
		0xf7,0xb0,0x73,0x8e,0x52,0x64,0x0e,0xda,0x2b,0xf3,0x10,0xc8,0xe5,0x79,0x90,0x80,
		0x6f,0xa0,0x8b,0xe9,0x3c,0x77,0x8c,0x44,0x04,0x72,0xcc,0x8e,0x02,0x22,0x00,0x01,
		0x44,0x16,0x49,0xac,0xb7,0x10,0x57,0xe5,0x75,0x8a,0xc0,0x46,0xad,0x2c,0x9b,0xc8,
		0xc2,0x9a,0x97,0xa3,0xd8,0xa6,0x5b,0x8e,0xe6,0xc9,0x2c,0xe1,0xba,0x72,0xb2,0x54,
		0x58,0x22,0xb4,0xf3,0x5c,0xbb,0x9e,0xb5,0xfe,0x64,0xfb,0xf8,0xf3,0x06,0x1e,0x49,
		0xa2,0xdf,0x65,0x4d,0x0d,0x62,0xe5,0xb1,0x31,0x9c,0x89,0xea,0x1a,0x3c,0xcc,0x2d,
		0x3c,0xfe,0x6c,0x5b,0x2b,0xa0,0x45,0xc7,0x72,0xa5,0xb9,0xf8,0x04,0x99,0x2a,0x46,
		0xf8,0xb7,0xdd,0xc5,0x76,0x3c,0x93,0xbe,0xa6,0x46,0x4f,0x0b,0xaf,0xbd,0x80,0xfc,
		0xd0,0x7a,0xdc,0xb5,0x09,0xfb,0xcf,0xf7,0x93,0x43,0xec,0xa7,0x17,0x5e,0x29,0x9c,
		0x9a,0xb8,0x23,0x50,0x84,0x1d,0xc5,0x3b,0x37,0x19,0x4b,0xd0,0x8e,0x8b,0x4e,0x7b,
		0x44,0x45,0xb3,0x41,0xb9,0x92,0x05,0xab,0x5e,0xf1,0x92,0xce,0xd9,0x81,0x13,0x42,
		0xe7,0x63,0x97,0x65,0x87,0x70,0x81,0x8c,0x43,0x39,0x30,0x12,0x1e,0xa5,0xe6,0x6b,
		0xc4,0x49,0xb1,0x9e,0x5d,0x9c,0xd6,0x79,0x7c,0xa2,0xb4,0xfe,0xfd,0xd7,0xb6,0xea
	};

	//char[] test_key_256 = {0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
    // 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};
	UCHAR expandkey_256[BLOCK_SIZE * 15] = {
		0x10,0xeb,0x3d,0x60,0xbe,0x71,0xca,0x15,0xf0,0xae,0x73,0x2b,0x81,0x77,0x7d,0x85,
		0xd1,0x90,0x48,0xfe,0x0b,0x8d,0x18,0xe6,0x44,0xf3,0x6d,0x04,0x1e,0x63,0x6c,0x70,
		0x49,0x3f,0xa2,0xad,0x24,0x3b,0xe2,0x63,0x8a,0x7c,0x42,0x55,0x04,0x91,0x70,0x5c,
		0xf6,0x6c,0xc9,0x57,0xc0,0x07,0x4f,0x07,0x07,0xbb,0x6a,0x70,0x41,0x92,0x7f,0x13,
		0x21,0xb6,0x68,0xb6,0x6d,0x04,0x40,0xce,0xae,0x47,0xa0,0x36,0x8e,0xed,0x32,0x09,
		0x44,0x1e,0xad,0x34,0x36,0x6b,0x86,0x50,0xc7,0xbc,0x25,0x77,0x46,0x29,0x15,0x63,
		0x36,0x6c,0x52,0x32,0x4c,0xb2,0x28,0x78,0xc3,0x43,0xe0,0xf8,0x20,0xaa,0x92,0x3f,
		0x89,0xb2,0x40,0xc4,0x72,0x75,0x2b,0x64,0xf1,0xd7,0xa3,0x27,0x81,0x95,0x30,0x14,
		0x33,0xa7,0x69,0xd6,0x7a,0xde,0x7a,0x4a,0x8f,0xf1,0xc8,0x80,0xe3,0xe9,0x72,0xc7,
		0x22,0x3c,0xba,0x25,0xfb,0xc7,0x6b,0xa0,0x83,0xa2,0x88,0x43,0x70,0x42,0x93,0x33,
		0x8b,0x80,0xfb,0x54,0x49,0x79,0x13,0x9c,0xf5,0x2f,0xb2,0xca,0x6c,0x18,0xba,0x47,
		0x29,0x63,0x3d,0x6c,0xd9,0xfb,0xd1,0x85,0x78,0x65,0xe3,0xe3,0xf3,0xe0,0x1b,0x70,
		0xf9,0x59,0x74,0x4a,0xc2,0xf9,0xe8,0xc8,0xbc,0x56,0xa1,0x56,0x99,0x37,0x08,0x8d,
		0x58,0x77,0x10,0x42,0xf0,0x98,0xec,0xe9,0xa1,0x9e,0x32,0x66,0x8b,0x85,0xf8,0x93,
		0xf6,0xbf,0xc6,0x8e,0x3b,0xa0,0x9c,0x82,0x7e,0xaf,0x49,0x9e,0x25,0x61,0xa9,0xdb
	};

	UCHAR iv[BLOCK_SIZE]= {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

	UCHAR** input = NULL;
	UCHAR** output= NULL;

	input = (UCHAR**)malloc(sizeof(UCHAR*) * chunkNum);
	output = (UCHAR**)malloc(sizeof(UCHAR*) * chunkNum);
	if(input == NULL || output==NULL) return -1;

	//random initialization
	time_t t;
    srand((unsigned) time(&t));
	for(i=0; i < chunkNum; i++) {
		input[i] = (UCHAR*) malloc(sizeof(UCHAR) * chunkSize);
		output[i] = (UCHAR*) malloc(sizeof(UCHAR) * chunkSize);
		if(input[i] == NULL) return -1;
		for (j=0; j < chunkSize; j++) {	
	        input[i][j] = (UCHAR) (rand() % 26 + 'a');
	    }
	}

	//benchmark
    struct timespec start_time, end_time;    
    size_t length = chunkSize;

    const UCHAR* expandkey = NULL;
    if(keybit_length == 192) {
    	expandkey = expandkey_192;
    } else if(keybit_length == 256) {
    	expandkey = expandkey_256;
    } else {
    	expandkey = expandkey_128;
	}

    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start_time);
    if(isParallel <= 0){
    	for(i=0; i < chunkNum; i++) {
			aes_cbc_decrypt_old(input[i], output[i], expandkey, iv, length, keybit_length);
			//aes_cbc_decrypt_noparallel(input[i], output[i], expandkey, iv, length);
		}
    } else {
    	for(i=0; i < chunkNum; i++) {
			aes_cbc_decrypt(input[i], output[i], expandkey, iv, length, keybit_length);
		}
    }
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end_time);

	double interval_sec  = timediff(start_time.tv_sec, start_time.tv_nsec, end_time.tv_sec, end_time.tv_nsec);
	printf("%f senconds", interval_sec);

	//clean:
	for(i=0; i < chunkNum; i++) {
	 	free(input[i]);
	 	free(output[i]);
	}	
	free(input);
	free(output);

	return interval_sec;
}

int test_performance_print (int chunkNum, int chunkSize, int keybit_length, int isParallel, int isWarmUp) {
	
	double interval_sec_sum = 0.0;
	int itrNum = 3;
	int i = 0;

	//re-generate data to clean the CPU cache each time.
	for(i=0; i< itrNum; i++) {
		interval_sec_sum += _performance_interval( chunkNum,  chunkSize,  keybit_length,  isParallel);
	}

	double total = (double)(chunkNum * chunkSize) / (1024*1024) ;
	printf("%s,", isParallel<=0? "(old version)" : "(new version)");
	double chunkSizeM = chunkSize / (1024*1024) ;
	double chunkSizeK = chunkSize / 1024 ;
	printf("total=%.2fMB, chunkSize=%.2f%s.", 
		total, 
		chunkSizeM >= 1.0 ? chunkSizeM : chunkSizeK,
		chunkSizeM >= 1.0 ? "MB" : "KB");
	printf(" key=%d: ", keybit_length);

	if(isWarmUp>0) {
		printf(" Warm up CPU.\n");
	} else {
		printf("thoughput:\t%.2f MB/s\n", (itrNum*total)/interval_sec_sum);
	}

	return 0;
}

int verify(){

	int i = 0;
	int errNo = 0;

	//key {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
	char expectedOutput[] = {
            0x12,0x29,0xbd,0x07,0xcb,0xa7,0x82,0xa4,0x6c,0x4c,0xb0,0x37,0x49,0x3d,0xbf,0x44,
            0x19,0x80,0x66,0xa7,0xa7,0x33,0x8d,0xd0,0x28,0x88,0x5e,0x20,0xfc,0xa0,0xfb,0x60,
            0xd2,0x2f,0x85,0x59,0x12,0x42,0xd7,0x22,0xdc,0x83,0x45,0x4f,0x3a,0xfa,0x7d,0xe0,
            0x56,0x07,0x03,0xd9,0xe8,0x21,0xe6,0xfe,0x84,0x5c,0x5a,0x49,0x2a,0x61,0xca,0x6b,
            0xa4,0xf7,0x1f,0xb0,0x78,0x5d,0x48,0x8c,0xb1,0x71,0x5a,0x83,0xc8,0xa7,0x4f,0x5d,
            0x8e,0x19,0xc0,0x51,0x14,0x81,0xca,0xad,0xd5,0x31,0xed,0x1c,0xb4,0xc7,0xf7,0x0a,
            0xbb,0xf5,0x82,0xba,0x30,0xda,0x1c,0xd9,0x73,0x27,0x51,0xd2,0xee,0x0a,0x50,0x87,
            0xc1,0x37,0x38,0xa3,0x91,0x30,0xe0,0x92,0x5a,0x2a,0x52,0xa8,0x93,0x20,0xa4,0x39,
            0xbb,0x26,0x78,0xb0,0x38,0x1a,0x31,0x30,0x2e,0x24,0x3a,0x92,0xca,0x99,0x81,0xb0,
            0xad,0xb9,0xf3,0x51,0x6b,0x7e,0x23,0x9f,0x18,0x75,0x5d,0x55,0xf2,0x87,0x8f,0xe0,
            0x82,0xa7,0xbc,0x12,0xb9,0x12,0x61,0xc8,0x38,0xe2,0x26,0x5f,0x2a,0x2d,0xb0,0x72,
            0x1e,0x51,0xed,0xec,0x9f,0xdd,0xfa,0x4e,0x1c,0x8c,0x91,0xcf,0x5e,0x1c,0xfa,0x54,
            0x5a,0xc9,0x95,0xcd,0x0f,0x93,0x6f,0x66,0x18,0xde,0x81,0x9f,0xa0,0x61,0x65,0xfa};

	
	UCHAR expandkey[BLOCK_SIZE * 11]= {
			0x16,0x15,0x7e,0x2b,0xa6,0xd2,0xae,0x28, 0x88,0x15,0xf7,0xab,0x3c,0x4f,0xcf,0x09,
			0xa8,0xf9,0x14,0xd0,0x89,0x25,0xee,0xc9, 0xc8,0x0c,0x3f,0xe1,0xa6,0x0c,0x63,0xb6,
			0x63,0x5a,0x7b,0x0c,0xfe,0xea,0x19,0x13, 0x90,0x88,0x39,0xb0,0xb4,0xfb,0x4c,0x66,
			0x5a,0x92,0x7d,0xdf,0x9d,0xb0,0x62,0x1f, 0x6e,0x62,0x20,0xa3,0x24,0x73,0x75,0xd6,
			0x47,0x76,0xc0,0x12,0xc7,0x22,0x1f,0xc0, 0xf3,0xd2,0x42,0xbc,0x4a,0x11,0x55,0x75,
			0x76,0xd8,0xfc,0x6e,0x80,0x54,0xdf,0xd2, 0x34,0xf0,0x5d,0x7c,0xb9,0xc3,0x17,0xc9,
			0xfc,0x0a,0xa3,0x6e,0xf6,0x8c,0x23,0xbc, 0xb4,0xa4,0x82,0xae,0x8d,0x33,0x4a,0xb5,
			0x13,0x44,0x88,0x90,0x0a,0x86,0x80,0xd2, 0x42,0x28,0xa1,0x12,0x39,0x97,0xc8,0x1b,
			0xf7,0x13,0x1f,0x7c,0x19,0xc2,0x08,0x42, 0x48,0xae,0x21,0xc0,0x7b,0xbf,0x69,0x09,
			0xeb,0x05,0x75,0xcc,0xee,0xd1,0x17,0x3e, 0x51,0x6c,0x29,0x82,0x33,0x11,0x48,0xc9,
			0xa7,0x08,0x37,0x2b,0x05,0xd4,0x62,0xf2, 0xbf,0xbd,0x3e,0xbc,0x62,0x7d,0x61,0x4b};

	UCHAR iv[BLOCK_SIZE]= {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

	UCHAR input[BLOCK_SIZE * 13];
	UCHAR output[BLOCK_SIZE * 13];
	size_t length = BLOCK_SIZE * 13;

	for (i=0; i < length; i++) {
        input[i] = (UCHAR) ('a' + i % 26);
    }

    UCHAR newIV[BLOCK_SIZE];
    for (i = 0; i < BLOCK_SIZE; ++i) {
    	newIV[i] = iv[i];
    }
	int retLen = aes_cbc_decrypt_old(input, output, expandkey, newIV, length, 128);
	errNo = cmp_array(output, expectedOutput, length);

	if(!errNo) {
		printf("(old version) sanity test passed.\n");
	} else {
		printf("(old version) sanity test failed!\n");
		return errNo;
	}

	for (i = 0; i < BLOCK_SIZE; ++i) {
    	newIV[i] = iv[i];
    }
	aes_cbc_decrypt(input, output, expandkey, newIV, length, 128);
	errNo = cmp_array(output, expectedOutput, length);

	if(!errNo) {
		printf("(new version) sanity test passed.\n");
	} else {
		printf("(new version) sanity test failed!\n");
	}

	return errNo;
}

/****************/
int cmp_array(const UCHAR *input, const UCHAR* expect, int length) {
	int i = 0;
	int errNo = 0;
	for(i=0; i< length; i++) {
		if(*(input+i) != *(expect+i)) {
			printf("Error @%d: expected:%x, actual:%x\n",  i, *(expect+i), *(input+i));
			errNo++;
		}
	}
	return errNo;
}

// timespec diff(timespec start, timespec end)
// {
//         timespec temp;
//         if ((end.tv_nsec - start.tv_nsec) < 0) 
//         {
//                 temp.tv_sec = end.tv_sec - start.tv_sec - 1;
//                 temp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
//         } 
//         else 
//         {
//                 temp.tv_sec = end.tv_sec - start.tv_sec;
//                 temp.tv_nsec = end.tv_nsec - start.tv_nsec;
//         }
//         return temp;
// }

double timediff(long start_tv_sec, long start_tv_nsec, long end_tv_sec, long end_ntv_sec)
{
	long tmp_nsec = 0;
	long tmp_sec = 0;
    if ((end_ntv_sec - start_tv_nsec) < 0) 
    {
        tmp_sec = end_tv_sec - start_tv_sec - 1;
        tmp_nsec = 1000000000 + end_ntv_sec - start_tv_nsec;
    } 
    else 
    {
        tmp_sec = end_tv_sec - start_tv_sec;
        tmp_nsec = end_ntv_sec - start_tv_nsec;
    }
    return tmp_sec + ((double)tmp_nsec) / 1000000000;
}